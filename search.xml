<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190806]]></title>
    <url>%2F2019%2F08%2F06%2F2019080601%2F</url>
    <content type="text"><![CDATA[使用Jest， Enzyme等工具进行单元测试React让前端单元测试变得容易 React应用很少需要访问浏览器API 虚拟DOM可以在NodeJS环境运行和测试 Redux隔离了状态管理，纯数据层单元测试 单元测试涉及的工具 Jest：Facebook开源的JS单元测试框架 const add = require(&#39;./add&#39;); describe(&#39;add&#39;, () =&gt; { it(&#39;should add two numbers&#39;, () =&gt; { expect(add(1, 2).toBe(3)); }) }) JS DOM：浏览器环境的NodeJS模拟 const JSDOM = require(&#39;jsdom&#39;).JSDOM; global.window = new JSDOM(&#39;&lt;!DOCTYPE html&gt;&lt;div id=&quot;react-root&quot;&gt;&lt;/div&gt;&#39;).window; global.document = window.document; global.navigator = window.navigator; global.HTMLElement = window.HTMLElement; Enzyme：React组件渲染和测试 import React from &#39;react&#39;; import { shallow } from &#39;enzyme&#39;; import { DefaultPage } from &#39;src/features/home/DefaultPage&#39;; describe(&#39;home/DefaultPage&#39;, () =&gt; { it(&#39;renders node with correct class name&#39;, () =&gt; { const pageProps = { home: {}, actions: {}, }; const renderedComponent = shallow( &lt;DefaultPage {...pageProps} /&gt; ); expect( renderedComponent.find(&#39;.home-default-page&#39;).getElement() ).to.exist; }); }); nock：模拟HTTP请求 it(&#39;handles fetchRedditReactjsList failure&#39;, () =&gt; { nock(&#39;http://www.reddit.com/&#39;) .get(&#39;/r/reactjs.json&#39;) .reply(500, null); const store = mockStore({ redditReactjsList: []}); return store.dispathc(fetchRedditReactjsList()) .catch(() =&gt; { const actions = store.getActions(); expect(actions[0]).to.have.property(&#39;type&#39;, HOME_FETCH_REDDIT_REACTJS_LIST_BEGIN); expect(actions[1]).to.have.property(&#39;type&#39;, HOME_FETCH_REDDIT_REACTJS_LIST_FAILURE): expect(actions[1]).to.have.nested.property(&#39;data.error&#39;).that.exist; }); }); sinon：函数模拟和调用跟踪 it(&#39;counter actions are called when buttons clicked&#39;, () =&gt; { const pageProps = { home: {}, actions: { counterPlusOne: sinon.spy(), counterMinusOne: sinon.spy(), resetCounter: sinon.spy(), fetchRedditReactjsList: sinon.spy(), }, }; const renderedComponent = shallow( &lt;DefaultPage {...pageProps} /&gt; ); renderedComponent.find(&#39;.btn-plus-one&#39;).simulate(&#39;click&#39;); renderedComponent.find(&#39;.btn-minus-one&#39;).simulate(&#39;click&#39;); renderedComponent.find(&#39;.btn-reset-counter&#39;).simulate(&#39;click&#39;); renderedComponent.find(&#39;.btn-fetch-reddit&#39;).simulate(&#39;click&#39;); expect(pageProps.actions.counterPlusOne).to.have.property(&#39;callCount&#39;, 1); expect(pageProps.actions.counterMinusOne).to.have.property(&#39;callCount&#39;, 1); expect(pageProps.actions.resetCounter).to.have.property(&#39;callCount&#39;, 1); expect(pageProps.actions.fetchRedditReactjsList).to.have.property(&#39;callCount&#39;, 1); }) istanbul：单元测试覆盖率 常用开发调试工具 ESLint 使用.eslintrc进行规则的配置 使用airbnb的JavaScript代码风格 Pretter 代码过格式化的神器 保证更容易写出风格一致的代码 React DevTool Redux DevTool]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190805]]></title>
    <url>%2F2019%2F08%2F05%2F2019080501%2F</url>
    <content type="text"><![CDATA[UI组件库对比和介绍 Ant.DesignAnt.Design是蚂蚁金服开源的一个React UI组件库，主要适合研发企业级中后台产品。 Material UIMaterial UI是Google开源的React UI组件库，整体风格可能更加活泼，色彩更加丰富，适合面向消费者的产品。 Semantic UISemantic UI是一个老牌的UI组件库，其历史可以追溯到jQuery时代。选择 UI 库的考虑因素 组件库是否齐全antd拥有更齐全的组件库，如常用的Tree组件以及表格组件中的固定行、列等。 样式风格是否符合业务需求antd设计风格简约直观，适合中后台系统，Matereial UI颜色更加大胆，可以用作面向消费者的产品 API设计是否便捷和灵活组件API使用方式是否高效，antd专注于数据填充，免去其他两个框架对html细节的要求 技术支持是否完善issue维护是否能够迅速响应，文档是否完善 开发是否活跃项目团队更新和修复issue是否频繁且快速 使用Next.js 创建React同构应用什么是同构应用？同构应用是指浏览器初次发送请求后，由服务器渲染好页面返回到浏览器，浏览器后续的路由控制和UI渲染继续由前端控制的应用 创建页面 页面就是pages目录下的一个组件 static目录映射静态文件 page具有特殊静态方法getInitialProps 在页面中使用其他React组件 页面也是标准的node模块，可使用其它React组件 页面会针对性打包，仅包含其引入的组件 使用Link实现同构路由 使用next/link定义链接 点击链接时页面不会刷新 使用prefetch预加载目标资源 使用replace属性替换URL import Link from &#39;next/link&#39; export default () =&gt; &lt;div&gt; Click{&#39; &#39;} &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;here&lt;/a&gt; &lt;/Link&gt;{&#39; &#39;} to read more &lt;/div&gt; 动态加载页面next支持实现页面的动态加载（懒加载），动态加载的页面会在打包文件的main.js外额外增加一个组件代码包。 import dynamic from &#39;next/dynamic&#39; const DynamicComponentWithCustomLoading = dynamic( import(&#39;../componets/hello2&#39;), { loading: () =&gt; &lt;p&gt;...&lt;/p&gt; } ) export default () =&gt; &lt;div&gt; &lt;Header /&gt; &lt;DynamicComponentWithCustomLoading /&gt; &lt;p&gt;HOME PAGE is here!&lt;/p&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190803]]></title>
    <url>%2F2019%2F08%2F04%2F2019080301%2F</url>
    <content type="text"><![CDATA[React RouterReact Router 虽然不是 React 官方出的，但是发展到现在已经成为 React 生态中路由的一种实现标准。 为什么需要路由？ 单页应用需要进行页面切换现代前端框架构建的单页面应用仍然有页面切换的需要。 通过 URL 可以定位到页面有了路由之后，用户可以通过具体的 URL 定位到对应的页面。 更有语义的组织资源语义化的 URL 可以对应页面级别的组件，组织代码等资源。 路由实现的基本架构首先由路由定义，定义具体路径匹配后渲染的组件名称，经过 Router 处理后，在组件容器中渲染对应组件的代码。 React Router 的实现下面是 React Router 实现的一个简单例子： &lt;Router&gt; &lt;div&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/hello&quot;&gt;Hello&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page-container&quot;&gt; &lt;Route path=&quot;/home&quot; component={Home} /&gt; &lt;Route path=&quot;/hello&quot; component={Hello} /&gt; &lt;Route path=&quot;/about&quot; component={About} /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; React Router 的特性 声明式路由定义React Router 只需要定义好匹配路径，指定匹配成功渲染的组件名称，即可定义路由 动态路由React Router 的路由表并不是读取一个静态的路由表，而是在代码解析时完成路由的定义 三种路由实现方式 URL 路径类似传统页面跳转，可以在页面不会刷新就可以实现浏览器地址栏的路径切换 hash 路由有些老版本浏览器不支持 URL 路径变化时保持页面不刷新，可以采用这种路由方式，路径上带有#，实现页面不刷新路径切换 内存路由路由切换状态是保存在内存中的，因此路径切换后，浏览器地址不会变化，一般用在服务器渲染 基于路由配置进行资源组织路由不仅仅是用来实现页面切换，也能帮助我们基于路由来进行资源的组织，主要有以下三个优点： 实现业务逻辑的松耦合 易于扩展，重构和维护 路由层面实现 Lazy Load React Router API &lt;LInk&gt;普通链接，不会触发浏览器刷新 import { Link } from &quot;react-router-dom&quot;; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;; &lt;NavLInk&gt;类型 Link 但是会添加当前选中状态 &lt;NavLink to=&quot;/faq&quot; activeClassName=&quot;selected&quot;&gt;FAQs&lt;/NavLink&gt;` &lt;Prompt&gt;满足条件时提示用户是否离开当前页面 import { Prompt } from &quot;react-router&quot;; &lt;Prompt when={formIsHalfFilledOut} message=&quot;Are you sure you want to leave?&quot; /&gt;; &lt;Redirect&gt;重定向当前页面，例如登录判断 import { Link } from &quot;react-router-dom&quot;; &lt;Route exact path=&quot;/&quot; render={() =&gt; loggedIn ? &lt;Redirect to=&quot;/dashboard&quot; /&gt; : &lt;PublicHomePage /&gt; } /&gt;; &lt;Route&gt;路由配置的核心标记，路径匹配时显示对应组件 import { BrowserRouter as Router, Route } from &quot;react-router-dom&quot;; &lt;Router&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component={Home} /&gt; &lt;Route path=&quot;/news&quot; component={NewFeed} /&gt; &lt;/div&gt; &lt;/Router&gt;; &lt;Switch&gt;只显示第一个匹配的路由 import { Switch, Route } from &quot;react-router&quot;; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={Home} /&gt; &lt;Route path=&quot;/about&quot; component={About} /&gt; &lt;Route path=&quot;/:user&quot; component={User} /&gt; &lt;Route component={NoMatch} /&gt; &lt;/Switch&gt;; React Router 参数定义通过 URL 传递参数 如何通过 URL 传递参数？&lt;Route path=&quot;/topic/:id&quot; ... /&gt; 如何获取参数this.props.match.params 一个将 url 转换成正则的方法path-to-regexp 何时需要 URL 参数页面状态尽量通过 URL 参数定义，如基于时间或其他条件的查询页面，可以将时间状态定义到 URL 中，这样做的好处可以免于维护组件内部的时间状态，实现 url 变化组件的状态随之变化。 理解 React Router 嵌套路由 每个 React 组件都可以是路由容器 React Router 的声明式语法可以方便的定义嵌套路由]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190802]]></title>
    <url>%2F2019%2F08%2F02%2F2019080201%2F</url>
    <content type="text"><![CDATA[在 React 中使用 Redux在 React 中使用 Redux 需要用到 react-redux 插件，这个插件封装了一个 connect 函数，connect 函数本质上是一个高阶函数，将 store 中组件需要用到的 state 和 dispacth 以 props 属性的形式传递，从而在组件内部可以获取相应状态和进行 action 操作。 import { connect } from &quot;react-redux&quot;; class SidePanel extends Component { // ... } function mapStateToProps(state) { return { nextgen: state.nextgen, router: state.router }; } function mapDispatchToProps(dispatch) { return { actions: bindActionCreators({ ...actions }, dispatch) }; } export default connect( mapStateToProps, mapDispatchToProps )(SidePanel); Redux 异步请求Redux 中支持异步请求，当 View 提交 Action 到 Dispatcher 时，先经过 Middlewares 中间件对异步请求（如 Ajax）进行处理，请求完成后根据不同的结果派发 dispatch 到 Reducer 进行下一步处理，再返回新的 state 映射到 View 上。另外需要注意，异步 action 不是特殊 action，而是多个同步 action 的组合使用。 Redux 中间件（Middleware）Redux 中间件是将 actionCreator 函数返回值由原来的对象替换为一个函数，这个函数的返回值是一个 Promise 函数，告诉 React 这是一个异步请求操作，中间件就会截获 action，等待 Promise 函数的返回结果分别执行不同的 dispatch 操作。 Redux 中 action 和 reducer 如何组织代码结构？标准形式传统 Redux Action 的组织形式是将所有的 action 存放在同一个文件中，这样会存在以下问题： 所有 Action 放一个文件，会无限扩展 Action，Reducer 分开，实现业务逻辑时需要来回切换 系统中有哪些 Action 不够直观 新的方式针对传统方式的缺点，可以将单个 action 和 reducer 放在同一个文件内，每个文件一个 Action，最后将所有的 action 和 reducer 分别导出在一个总的 action 和 reducer 入口文件中。这样做的优点主要有以下四点： 易于开发：不用再 action 和 reducer 文件间来回切换 易于维护：每个 action 文件都很小，容易理解 易于测试：每个业务逻辑只需对应一个测试文件 易于理解：文件名就是 action 名字，文件列表就是 action 列表 不可变数据（immutable data）不可变数据就是在数据更新时始终存在部分数据的值或者引用不变的数据 从上图可以看到，当不可变数据某个节点发生变化时，只会更新该节点直系上的数据，其他分支上的数据保持不变 为什么需要不可变数据？ 性能优化 易于调试和跟踪 易于推测 如何操作不可变数据? 原生写法：{...}，Object.assign在业务中常用，缺点是对象层级越多，代码结构越复杂 const state = { filter: &quot;completed&quot;, todos: [&quot;Learn React&quot;] }; // 对象扩展符 const newState = { ...state, todos: [...state.todos, &quot;Learn Redux&quot;] }; // ES6原生写法，性能最佳 const newState2 = Object.assign({}, state, { todos: [...state.todos, &quot;Learn Redux&quot;] }); immutability-helper适合对象嵌套层级较深的应用场景，写法相对简单优雅，缺点是需要使用特殊的语法 import update from &quot;immutability-helper&quot;; const state = { filter: &quot;completed&quot;, todos: [&quot;Learn React&quot;] }; const newState = update(state, { todos: { $push: [&quot;Learn Redux&quot;] } }); immer接近对象修改原生的写法，性能与前两者相比较差，适合小型应用或 demo 使用 import produce from &quot;immer&quot;; const state = { filter: &quot;completed&quot;, todos: [&quot;Learn React&quot;] }; const newState = produce(state, draftState =&gt; { draftState.todos.push(&quot;Learn Redux&quot;); });]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190801]]></title>
    <url>%2F2019%2F08%2F01%2F2019080101%2F</url>
    <content type="text"><![CDATA[理解 ReduxRedux 是一个 js 状态管理插件，它的设计模式被广泛用于现代前端框架中，尤其与 react.js 结合紧密。独立使用 react 时，组件的 DOM 的状态通常由内部 state 映射过来。而 Redux 将这种状态库从组件内部移到外部，由一个 store 进行统一管理，无论是父子、兄弟还是跨级组件之间的状态共享都是放在这个外部 store，这让组件通信更加容易。 Redux 特性 Single Source of Truth传统 MVC 架构，数据层 Model 与视图层 View 之间往往是多对多的关系，一个 view 上的状态可能受多个 model 控制，管理起来十分复杂。 而在 Redux 模式中，不同的 view 上的状态全部存放在外部一个统一的 Store 容器中，View 与 Store 之间是简单的一对一关系，数据流向清晰多了。 可预测性 Redux 中的数据变化是可以预测的，如果状态发生了变化，一定是在当前的 state 状态下派发了一个 action，其结果是返回一个新的 state 状态 纯函数更新 Store Redux 中数据状态的更新是由一个纯函数来处理，它接收当前的 state 状态和 action 对象作为参数，根据不同的 action 返回新的 state 状态。函数的输出都是依赖输入值的不同且确定的。 理解 StoreStore 是数据存放的容器，通过 createStore(reducer) 新建，getState() 可以获取当前的 state 值，如果修改state一定得通过diapatch(action)的方式派发一个 action，而subscribe(listener)用来监听 state 的响应变化 理解 actionaction 实际上是一个 javascript 对象，包括 action 的类型值和载荷 { type: ADD_TODO, text: &#39;Build my first Redux app&#39; } 理解 reducerreducer 实际上是一个纯函数，通过输入的 state 和action分别输出新的 state 值： function todos(state = [], action) { switch (action.type) { case &#39;ADD_TODO&#39;: return state.concat([{ text: action.text, completed: false }]) case &#39;TOGGLE_TODO&#39;: return state.map( (todo, index) =&gt; action.index === index ? { text: todo.text, completed: !todo.completed } ) default: return state } } Redux 的工作原理当前端交互需要改变状态时，首先会新建 action 对象，用来描述动作的类型和变化值，然后通过 Diapatcher 派发提交到 Store 中，经过 Reducer 函数基于当前 state 进行处理后，返回新的 State，然后映射到 DOM 上更新状态。 Redux 提供的工具函数 bindActionCreatorsbindActionCreators(ActionCreators, dispatch)接收两个参数，一个是创建 Action 的函数，一个是 dispatch 方法。函数的返回值是可以派发相应 action 的 dispatch 方法 function plusOne() { return { type: &quot;PLUS_ONE&quot; }; } plusOne = bindActionCreators(plusOne, store.dispatch); plusOne(); // 等价于 store.dispatch(plusOne()) combineReducerscombineReducers({reducer1, reducer2, ...})接收一个 reducers 对象,可以将不同的 reducer 同时连接到 store 上，每个 reducer 函数返回的 state 都相互独立。 import { combineReducers } from &quot;redux&quot;; const todos = (state = {}, action) =&gt; state; const counter = (state = {}, action) =&gt; state; const store = createStore( combineReducers({ todos, counter }) ); console.log(store); // {tods: {...}, counter: {...}}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190731]]></title>
    <url>%2F2019%2F07%2F31%2F2019073102%2F</url>
    <content type="text"><![CDATA[Virtual DOMReact 通过控制虚拟 DOM 的状态来实现 UI 的变化，虚拟 DOM 映射到实际的 DOM 节点上，当状态发生变化时，经过 diff 算法的计算，通知对应的 DOM 节点更新。 虚拟 DOM 是如何工作的？虚拟 DOM 计算 DOM 变化的 Diff 算法是根据广度优先分层比较：首先从根节点开始，每一层如果只是属性发生变化或者 DOM 标识的顺序发生了变化，就会在原有节点上更新或调整顺序，不发生移除和新增节点操作。如果节点类型发生变化，则会移除原有节点后新增节点。即使节点只是发生跨层移动，归属到另一个父节点下，仍然会移除原有节点，并在新的层级新增节点。 Diff 算法为了降低算法的复杂度，放弃了深度上的节点移动，是结合了 UI 更新的实际场景。通常，UI 变化以自身属性变化和同级顺序调整为主，几乎很少出现跨层移动的情况。所以放弃深度上的节点计算，能够降低算法复杂度O(n)，极大提高页面渲染性能。 虚拟 DOM 的两个假设 组件的 DOM 结构是相对稳定的 类型相同的兄弟节点可以被唯一标识（key 属性的重要性） 组件设计模式不同的组件设计模式是为了可以实现更多场景的组件复用 高阶组件（HOC）react 高阶组件本质上是一个函数，接收一个组件作为参数，返回新的组件 const EnhancedComponent = higherOrderComponent(WrappedComponent); 函数作为子组件组件里设计好子组件的使用形式，由使用者定义函数返回不同内容 class MyComponent extends React.Component { render() { return &lt;div&gt;{this.props.children(&quot;Nate Wang&quot;)}&lt;/div&gt;; } } &lt;MyComponent&gt;{name =&gt; &lt;div&gt;{name}&lt;/div&gt;}&lt;/MyComponent&gt; Context API(React 16.3 新增)Context API 主要由三个部分构成：context（存放状态数据）、provider（在父组件上提供共享状态）、consumer（在子组件上接收共享状态并使用）。 const ThemeContext = React.createContext(&quot;light&quot;); class App extends React.Component { render() { return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;ThemedButton /&gt; &lt;/ThemeContext.Provider&gt; ); } } function ThemedButton(props) { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; &lt;Button {...props} theme={theme} /&gt;} &lt;/ThemeContext.Consumer&gt; ); } 脚手架工具为什么需要脚手架工具？如今的前端开发初始化项目需要配置全家桶及相关的编译、打包、代码格式检查等插件，拿 react 全家桶举例，就得安装配置 React、Redux、React-Router 等，再加上 Babel、webpack、ESLint 等通用辅助插件。这些插件生态又依赖更多的插件，一个个了解并配置都比较麻烦，而且基本上初始构建开发环境的配置又大致相同，所以出现了许多脚手架工具帮助我们一键配置这些开发环境。 常见的脚手架工具 create-react-app # 适合新手入门使用，默认封装好最基础的开发配置 Rekit # 在 CRA 基础上增加了 Redux、React Router、Less/Scss 等 CodeSandbox # 一个在线开发工具 为什么需要打包？以往，只有后台语言项目才会有打包的概念，但是随着前端技术生态的发展，前端项目也需要借助打包工具来生成项目文件。主要有以下 3 个目的： 编译 ES6 语法特性，编译 JSX 整合资源，例如图片，Less/Sass 优化代码体积 前端项目目前主要使用 Webpack 进行打包 打包注意事项 设置 nodejs 环境为 production 禁用开发时专用代码，比如 logger 设置应用根路径]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190730]]></title>
    <url>%2F2019%2F07%2F30%2F2019073002%2F</url>
    <content type="text"><![CDATA[React 组件理解 React 组件 React 组件一般不提供方法，而是某种状态机 React 组件可以理解为一个纯函数 单向数据绑定 受控组件 vs 非受控组件React 组件可以根据组件状态是受内部还是外部控制分为受控组件和非受控组件两种 以表单元素为例，表单元素状态由使用者维护是受控组件： &lt;input type=&quot;text&quot; value={this.state.value} onChange={e =&gt; this.setState({ value: e.target.value })} /&gt; 如果表单元素状态由 DOM 自己维护，则属于非受控组件 &lt;input type=&quot;text&quot; ref={node =&gt; (this.input = node)} /&gt; 单一职责原则那么，什么时候创建组件呢？ 每个组件只做一件事 如果组件变得复杂，那么应该拆分成小组件 DRY 原则组件的数据状态管理尽可能遵守以下两点： 能计算得到的状态就不要单独存储 组件尽量无状态，所需数据通过 props 获取 JSXJSX 的本质JSX 不是一种模板语法，而是语法糖，它可以在代码中直接书写 html 标签动态创建组件，实质上底层使用了原生的document.createElement API const name = &quot;Nate Wang&quot;; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; 等同于下面 const name = &quot;Nate Wang&quot;; const element = React.createElement(&quot;h1&quot;, null, &quot;Hello, &quot;, name); JSX 表达式JSX 中使用表达式主要有以下四种情形： JSX 本身也是表达式const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 在属性中使用表达式&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt; 延展属性const props: {firstName: &#39;Ben&#39;, lastName: &#39;Hector&#39;}; const greeting = &lt;Greeting {...props}/&gt;; 表达式作为子元素const element = &lt;li&gt;{props.message}&lt;/li&gt;; JSX 的优点 声明式创建界面的直观 代码动态创建界面的灵活 无需学习新的模板语言 自定义组件命名规范自定义组件以大写字母开头，因为 React 认为小写的标签式原生 DOM 节点，大写字母开头的标签式自定义组件。另外 JSX 标记可以直接使用属性语法，例如&lt;menu.Item /&gt;，这里可以不受大写字母开头约定限制。 React 组件生命周期React 组件生命周期根据场景的不同可以分为挂载时、更新时、卸载时三种情况，每种情况又可以分为三个阶段，分别为“Render 阶段”、“Pre-commit 阶段”、“Commit 阶段”。具体生命周期（react 16.4^）如下图所示 下面简单介绍几个主要的生命周期钩子 constructor 用于初始化内部状态，很少使用 唯一可以直接修改 state 的地方 getDerivedStateFromProps (react 16.3 新增) 当 state 需要从 props 初始化时使用 尽量不要使用：维护两者状态一致性会增加复杂度 每次 render 都会调用 典型场景：表单控件获取默认值 componentDidMount UI 渲染完成后调用 只执行一次 典型场景：获取外部资源（ajax 请求接口数据） componentWillUnmount 组件移除时被调用 典型场景：资源释放 getSnapshotBeforeUpdate (react 16.3 新增) 在页面 render 之前调用，state 已更新 典型场景：获取 render 之前的 DOM 状态 componentDidUpdate 每次 UI 更新时被调用 典型场景：页面需要根据 props 变化重新获取数据 shouldComponentUpdate 决定 Virtual DOM 是否要重绘 一般可以由 PureComponent 自动实现 典型场景：性能优化]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《React实战进阶》 学习笔记 20190729]]></title>
    <url>%2F2019%2F07%2F29%2F2019072901%2F</url>
    <content type="text"><![CDATA[React 出现的历史背景及特性介绍历史背景facebook 的工程师在上线顶部状态栏后发现了一个 bug，点击消息通知后，图标上的悬浮的消息数量并没有更新或者消失。在这个“简单”的问题上，这个 bug 反复出现。 后来他们总结了问题出现的根源，主要有一下两点： 传统 UI 操作关注太多细节 应用程序状态分散在各处，难以追踪和维护 特性介绍 1 个新概念4 个必须 API单向数据流完善的错误提示 对于传统 DOM API 关注太多细节的问题，React 提出始终整体刷新页面，无需关注细节。 传统 MVC 数据模型难以扩展和维护，下图可以看到 Model 与 View 之间的关系错综复杂，数据双向绑定，遇到问题之后很难迅速判断到底是 Model 还是 View 上产生的。 那么 React 是如何解决数据模型的问题呢？React 提出了一个 Flux 架构，核心思想是单向数据流，React Views（UI）上发生用户操作时会产生一个 Action，这个 Action 会通过 Dispatcher 派发出去，由 Store 进行处理，而 React Views 是绑定在 Store 上的，所以当 Store 有任何变化时，React Views 会更新。Flux 架构是建立在 React 始终以状态为基础来展示 UI，所以不需要关心细节，就能把 React View connect 到 Store 上 Flex 架构的衍生项目 Redux MobX 小结 传统 Web UI 开发的问题 React：始终整体刷新页面 Flux：单向数据流]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsync 同步文件到服务器]]></title>
    <url>%2F2019%2F05%2F24%2F2019073001%2F</url>
    <content type="text"><![CDATA[rsync 简介rsync 是 linux 系统下的数据镜像备份工具。使用快速增量备份工具 Remote Sync 可以远程同步，支持本地复制，或者与其他 SSH、rsync 主机同步。 它的特性如下： 可以镜像保存整个目录树和文件系统。 可以很容易做到保持原来文件的权限、时间、软硬链接等等。 无须特殊权限即可安装。 快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改的文件。rsync 在传输数据的过程中可以实行压缩及解压缩操作，因此以使用更少的带宽。 安全：可以使用 scp、ssh 等方式来传输文件，当然也可以通过直接 socket 连接。 支持匿名传输，以方便进行网站镜像。 服务器端部署安装$ yum install -y rsync // CentOS 修改配置文件$ vi /etc/rsyncd.conf // rsyncd.conf #全局配置 uid = root gid = root incoming chmod = Du=rwx,Dog=rx,Fu=rwx,Fgo=rx exclude = node_modules/ .git/ # 模块配置 [www] host allow = * path = /home/wwwroot comment = www auth users = publish secrets file = /etc/rsyncd.passwd read only = no 创建密码文件$ vi /etc/rsyncd.passwd 备份用户:备份密码 // 如publish:abc123 指定目录并赋予权限chmod 600 /etc/rsyncd.passwd chown -R publish:publish 备份目录 启动/停止服务查看服务器进程 $ ps aux | grep rsync 杀死进程 $ pkill rsync 启动服务 $ rsync --daemon --config=/etc/rsyncd.conf 客户端(windows)安装cwRsync (windows 版) 配置文件结构– publish– – pubToProd.sh （备份脚本）– – PwdPubToProd.pwd （密码文件） 配置文件实例// pubToProd.sh echo &#39;*************发布正式环境******************&#39; echo &#39;* *&#39; echo &#39;* 地址: xxx.xxx.xxx.xxx *&#39; echo &#39;* 密码: 隐藏 *&#39; echo &#39;* *&#39; echo &#39;*******************************************&#39; echo &#39; &#39; echo &#39;* starting... *&#39; echo &#39; &#39; echo -n &quot; 确认发布到正式环境!!!!!!请输入(yes) -&gt; &quot; read int if [[ &quot;$int&quot; == &quot;yes&quot; || &quot;$int&quot; == &quot;y&quot; ]]; then echo &#39; &#39; echo &#39; &#39; rsync -aP --progress --password-file=&#39;客户端密码文件相对路径&#39; &#39;备份文件夹相对路径&#39; &#39;备份用户&#39;@&#39;IP地址&#39;::&#39;模块名&#39;/&#39;模块路径后相对路径&#39; echo &#39; &#39; echo &#39; &#39; echo &#39;******************END**********************&#39; echo &#39; &#39; else echo &#39; &#39; echo &#39; &#39; echo &#39;*******************************************&#39; echo &#39;* *&#39; echo -e &#39;* \033[31m 确认失败,请重新发布！ \033[0m *&#39; echo &#39;* *&#39; echo &#39;*******************************************&#39; fi // PwdPubToProd.pwd 备份密码]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>镜像备份</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node版本管理工具——nvm安装配置]]></title>
    <url>%2F2018%2F09%2F22%2F2019073101%2F</url>
    <content type="text"><![CDATA[前言现代前端框架的插件引入和打包构建都是基于 node 环境，对于前端童鞋来说，安装配置 node 环境是必须要掌握的基本技能。 一般来讲，直接从 node 官网上下载开发平台相关的安装包或二进制文件进行安装，就能满足正常的开发需求。但是随着 node 版本的不断完善和快速迭代，许多主流的前端框架会在较大的迭代版本中支持这些新出的特性，所以一些框架或插件会对项目运行时的最低 node 版本存在要求，如果低于该版本，则会编译报错。某些情况下，某些老项目插件在较高 node 版本时，也可能报错。因此，直接安装单一 node 版本的弊端就出现了，如果两个项目在高版本 node 和低版本 node 相互不兼容的情况下需要同时进行开发调试，不能灵活切换 node 版本会严重影响开发效率。 接下来就要介绍本期的主角—— nvm，它支持 Windows/MacOS/Linux 等多种开发平台，安装方式也十分简（sha）单（gua），本文主要讲下 windows 环境下的安装和配置 安装 nvmwindows安装 nvm-windows 下载地址 nvm 设置淘宝镜像源安装完成后，在 nvm 安装目录中找到 settings.txt 文件，在后面加上： node_mirror: http://npm.taobao.org/mirrors/node/ # 设置node镜像下载源地址 npm_mirror: https://npm.taobao.org/mirrors/npm/ # 设置npm镜像下载源地址 提示：如果不设置淘宝镜像源，可能由于网络错误导致 node 或 npm 下载缓慢甚至失败！ 使用 nvm 安装 node$ nvm install &#39;node版本号&#39; # 安装指定node版本 $ nvm use &#39;node版本号&#39; # 切换当前node版本 设置 npm 全局安装和缓存目录$ npm config set prefix &quot;E:\node\npm-global&quot; # 设置全局安装目录 $ npm config set cache &quot;E:\node\npm-cache&quot; # 设置全局缓存目录 为 npm 全局安装配置环境变量如果希望在 node 版本切换后，之前全局安装的 npm 插件依然能够正常使用，需要在系统环境变量里增加 NPM_HOME 变量，变量值是 npm 全局安装目录，需要放在其他 nvm 自动配置的变量前面 npm 设置淘宝镜像源# npm $ npm config set registry https://registry.npm.taobao.org --global # 插件库镜像源 $ npm config set disturl https://npm.taobao.org/dist --global # node源代码镜像源 # 安装cnpm $ npm install -g cnpm --registry=https://registry.npm.taobao.org # 一些难下载的包 $ npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ # node-sass插件 $ npm config set phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ # phantomjs插件]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
</search>
